.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tree::AVL 3"
.TH Tree::AVL 3 "2009-05-23" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree::AVL \- An AVL (balanced binary) tree for time efficient storage and retrieval of comparable objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tree::AVL;
.Ve
.Sh "\s-1EXAMPLE\s0 1"
.IX Subsection "EXAMPLE 1"
.Vb 6
\& #  This example shows usage with default constructor.
\& #
\& #  By default, the tree works with strings.  The 
\& #  constructor can also be passed a comparison function
\& #  and accessor methods to use, so that you can store any
\& #  type of object you\*(Aqve defined in the tree. (see Example 2).
\&
\& # create a tree with default constructor
\& my $avltree = Tree::AVL\->new();
\& 
\& # can insert strings by default
\& $avltree\->insert("arizona");  
\& $avltree\->insert("arkansas");
\& $avltree\->insert("massachusetts");
\& $avltree\->insert("maryland");
\& $avltree\->insert("montana");
\& $avltree\->insert("madagascar"); # just seeing if you\*(Aqre paying attention..
\&
\& print $avltree\->get_height() . "\en";  # output: 2 (height is zero\-based) 
\&
\& $avltree\->print("*"); # output:
\&                       #
\&                       # *maryland: maryland: height: 2: balance: 0
\&                       # **massachusetts: massachusetts: height: 1: balance: 0
\&                       # ***montana: montana: height: 0: balance: 0
\&                       # **arkansas: arkansas: height: 1: balance: 0
\&                       # ***madagascar: madagascar: height: 0: balance: 0
\&                       # ***arizona: arizona: height: 0: balance: 0
\& 
\& my $obj = $avltree\->remove("maryland");
\& print "found: $obj\en";  # output: found: maryland
\& my $obj = $avltree\->remove("maryland");
\& if(!$obj){
\&     print "object was not in tree.\en";
\& }
\& 
\& $avltree\->print("*"); # output:
\&                       # 
\&                       # *madagascar: madagascar: height: 2: balance: 0
\&                       # **massachusetts: massachusetts: height: 1: balance: 0
\&                       # ***montana: montana: height: 0: balance: 0
\&                       # **arkansas: arkansas: height: 1: balance: 1
\&                       # ***arizona: arizona: height: 0: balance: 0
\&
\& # retreive an iterator over the objects in the tree.
\& my $iterator = $avltree\->iterator();
\& while(my $obj = $iterator\->()){
\&     print $obj . "\en";   # outputs objects in order low\-to\-high
\& } 
\& 
\& # retreive a reverse\-order iterator over the objects in the tree.
\& my $iterator = $avltree\->iterator(">");
\& while(my $obj = $iterator\->()){
\&     print $obj . "\en"; # outputs objects in order high\-to\-low
\& }
\&
\& # retrieve all objects from tree at once
\& my @list = $avltree\->get_list();
\& foreach my $obj (@list){
\&     print $obj . "\en"; # outputs objects in order low\-to\-high
\& } 
\&
\& my $obj = $avltree\->pop_smallest();  # retrieves arizona
\& print "$obj\en"; 
\&
\& my $obj = $avltree\->pop_largest();  # retrieves montana
\& print "$obj\en"; 
\&  
\& undef $avltree;
.Ve
.Sh "\s-1EXAMPLE\s0 2"
.IX Subsection "EXAMPLE 2"
.Vb 10
\& #  Shows how to instantiate tree and specify key, data and
\& #  comparison functions, so you can store any object
\& #  you want.   Here a basic hash is used, but 
\& #  any object of your creation will do when you 
\& #  supply an appropriate comparison function.
\& # 
\& #  Note:  in this example, anonymous subroutines are
\& #  passed in to the constructor, but you can just as well supply
\& #  your own object\*(Aqs comparison methods by name\-   i.e.,
\& #
\& #  $avltree = Tree::AVL\->new(
\& #          fcompare => \e&MyObj::compare,
\& #           
\& #          . . . 
\& #           
\& #          etc...
\&  
\& 
\& my $elt1 = { _name => "Bob",
\&             _phone => "444\-4444",}; 
\& 
\& my $elt2 = { _name => "Amy",
\&             _phone => "555\-5555",}; 
\& 
\& my $elt3 = { _name => "Sara",
\&             _phone => "666\-6666",}; 
\& 
\& $avltree = Tree::AVL\->new(
\&     fcompare => sub{ my ($o1, $o2) = @_;
\&                     if($o1\->{_name} gt $o2\->{_name}){ return \-1}
\&                     elsif($o1\->{_name} lt $o2\->{_name}){ return \-1}
\&                     return 0;},
\&     fget_key => sub{ my($obj) = @_;
\&                     return $obj\->{_name};},
\&     fget_data => sub{ my($obj) = @_;
\&                      return $obj\->{_phone};},
\&     );
\& 
\& $avltree\->insert($elt1);
\& $avltree\->insert($elt2);
\& $avltree\->insert($elt3);
\& 
\& 
\& $avltree\->print("\-");   # output:
\&                         #
\&                         # \-Bob: 444\-4444: height: 1: balance: 1
\&                         # \-\-Amy: 555\-5555: height: 0: balance: 0
\&                         # \-\-Sara: 666\-6666: height: 0: balance: 0
\&
\& $avltree\->insert($elt4); # output: "Error: inserted uninitialized object.."
\&  
\&
\& exit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1AVL\s0 Trees are balanced binary trees, first introduced in 
\&\*(L"An Algorithm for the Organization of Information\*(R" by Adelson-Velskii and Landis
in 1962.
.PP
Balance is kept in an \s-1AVL\s0 tree during insertion and deletion
by maintaining a 'balance' factor in each node.
.PP
If the subtree rooted at any node in the tree is evenly balanced,
the balance factor for that node will be 0.
.PP
When the right-subtree below a node is taller than the left-subtree,
the balance factor will be 1.  For the opposite case, the balance
factor will be \-1.
.PP
If the either subtree below a node is heavier (taller by more than 2 levels) 
than the other, the balance factor within the node will be set to (+\-)2, 
and the subtree rooted at that node will be rebalanced.
.PP
Re-balancing is done via 'single' or 'double' rotations, each of which
takes constant time.
.PP
Insertion into an \s-1AVL\s0 tree will require at most 1 single or double rotation.
.PP
Deletion from an \s-1AVL\s0 tree may take as much as log(n) rotations
in order to restore balance.
.PP
Balanced trees can save huge amounts of time in your programs
when used over regular flat data structures.  For example, if 
you are processing as much as 1,125,899,906,842,624 ordered objects 
on some super awesome mega workstation, the worst-case time (comparisons)
required  to access one of those objects will be 1,125,899,906,842,624 if
you keep them in a flat data structure.    However, using a balanced 
tree such as a 2\-3 tree, a Red-Black tree or an \s-1AVL\s0 tree, the worst-case 
time (comparisons) required will be just 50.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\& my $avltree = Tree::AVL\->new();  # optionally pass in comparison, key accessor, and data accessor functions
.Ve
.PP
Creates a new \s-1AVL\s0 tree object.  Without any arguments, the constructor returns a tree that works with strings and
uses lexical comparison.   If you pass it an appropriate comparison function, the returned tree will work with any object of your
creation.   Also, you can pass in functions to get the 'key' and 'data' of any object as well (this is useful for printing
the contents of the tree).
.Sh "\fIinsert()\fP"
.IX Subsection "insert()"
.Vb 1
\& $avltree\->insert($thing);
.Ve
.PP
Places an object or thing in the tree.  Note:  This function and others have been implemented using iterative methods rather than recursive
calls in order to reduce subroutine-call overhead and enhance efficiency.
.Sh "\fIremove()\fP"
.IX Subsection "remove()"
.Vb 1
\& my $deleted_thing = $avltree\->remove($thing);
.Ve
.PP
Removes items from the tree.
.Sh "\fIlookup()\fP"
.IX Subsection "lookup()"
.Vb 1
\&    my $found_thing = $avltree\->lookup($thing);
.Ve
.PP
Looks for \f(CW$thing\fR in the tree, returns reference to \f(CW$thing\fR if found, or nil if not found.
.Sh "\fIacc_lookup()\fP"
.IX Subsection "acc_lookup()"
.Vb 1
\&    my @found_things = $avltree\->acc_lookup($thing, $partial_cmp_func, $precise_cmp_func);
.Ve
.PP
Accumulative lookup, returns a list of all items whose keys satisfy the match function for the key for \f(CW$object\fR. 
For example, suppose you have a \*(L"relaxed\*(R" compare function such as:
.PP
.Vb 1
\&    $word\->compare_up_to($arg_word);
.Ve
.PP
which returns true if the argument word is a proper 'superstring' of \f(CW$word\fR (meaning that it contains \f(CW$word\fR 
followed by one or more characters).
.PP
If you call \fIacc_lookup()\fR with this function as a parameter, \fIacc_lookup()\fR will return a list of all the words in
the tree that are superstrings of \f(CW$word\fR.   acc_lookup uses the tree property to do this in O(log(n)) time.
.Sh "\fIlargest()\fP"
.IX Subsection "largest()"
.Vb 1
\& my $largest_thing = $avltree\->largest();
.Ve
.PP
Returns the largest item in the tree.
.Sh "\fIsmallest()\fP"
.IX Subsection "smallest()"
.Vb 1
\& my $smallest_thing = $avltree\->smallest();
.Ve
.PP
Returns the smallest item in the tree.
.Sh "\fIiterator()\fP"
.IX Subsection "iterator()"
.Vb 1
\& my $it = $avltree\->iterator();
.Ve
.PP
Returns an iterator over the items in the tree.  By Default the iterator is in-order from lowest to highest.  If you pass in the parameter \*(L">\*(R", the order
of the items returned by the iterator will be from highest to lowest.
.Sh "\fIget_root()\fP"
.IX Subsection "get_root()"
.Vb 1
\&    my $root_obj = get_root();
.Ve
.PP
Returns a reference to the object stored at the root of the tree.
.Sh "\fIprint()\fP"
.IX Subsection "print()"
.Vb 1
\& $avltree\->print();
.Ve
.PP
Dumps the contents of the tree to \s-1STDOUT\s0.   If passed an additional string parameter, it will be used to visually distinguish objects by their respective heights
in the tree (by prepending the string passed-in to the object's printed value).
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
This module requires these other modules and libraries:
.PP
Test::More (required for installation test)
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"An Algorithm for the Organization of Information\*(R",  G.M. Adelson-Velsky and
E.M. Landis.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matthias Beebe, <matthiasbeebe@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009 by Matthias Beebe
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.
